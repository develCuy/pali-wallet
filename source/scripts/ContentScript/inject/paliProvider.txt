const SUPPORTED_CHAINS = {
  syscoin: {
    prefix: 'sys',
    asset: 'SYS',
  },
  ethereum: {
    prefix: 'eth',
    asset: 'ETH',
  },
};

const { SUPPORTED_WALLET_METHODS } = window;

const REQUEST_MAP = {
  ETH: {
    chainId: SUPPORTED_WALLET_METHODS.getChainId,
    setAccount: SUPPORTED_WALLET_METHODS.setAccount,
    accounts: SUPPORTED_WALLET_METHODS.getAccounts,
    blockNumber: SUPPORTED_WALLET_METHODS.getBlockNumber,
    estimateGas: SUPPORTED_WALLET_METHODS.estimateGas,
    sendTransaction: SUPPORTED_WALLET_METHODS.sendTransaction,
    signMessage: SUPPORTED_WALLET_METHODS.signMessage,
    getBalance: SUPPORTED_WALLET_METHODS.getBalance,
  },
  SYS: {
    setAccount: SUPPORTED_WALLET_METHODS.setAccount,
    chainId: SUPPORTED_WALLET_METHODS.getChainId,
    accounts: SUPPORTED_WALLET_METHODS.getAccounts,
    sendTransaction: SUPPORTED_WALLET_METHODS.sendTransaction,
    getPublicKey: SUPPORTED_WALLET_METHODS.getPublicKey,
    signMessage: SUPPORTED_WALLET_METHODS.signMessage,
    getBalance: SUPPORTED_WALLET_METHODS.getBalance,
  },
  isConnected: SUPPORTED_WALLET_METHODS.isConnected,
  getNetwork: SUPPORTED_WALLET_METHODS.getNetwork,
  getAddress: SUPPORTED_WALLET_METHODS.getAddress,
};

const ERRORS = {
  USER_REJECTED: new Error('User rejected the request'),
  INVALID_METHOD: new Error('Invalid method'),
};

const handleRequest = async (chain, request) => {
  const { asset } = SUPPORTED_CHAINS[chain];

  const provider = window.providerManager.getProviderFor(asset);

  if (request.method === 'personal_sign') {
    request.method = 'eth_signMessage';
  }

  let [prefix, method] = request.method.split('_');

  if (!method) {
    prefix = null;
    method = request.method;
  } else {
    prefix = prefix.toUpperCase();
  }

  //* Prefix / Method validation
  let methodIsValid;
  if (prefix) {
    if (prefix.toLowerCase() !== SUPPORTED_CHAINS[chain].prefix) {
      throw ERRORS.INVALID_METHOD;
    }

    methodIsValid = Boolean(REQUEST_MAP[prefix][method]);
  } else {
    methodIsValid = Boolean(REQUEST_MAP[method]);
  }

  if (!methodIsValid) throw ERRORS.INVALID_METHOD;

  // All request accounts go to the same place
  if (method === 'getAccounts') {
    const { result, data } = await window.providerManager.enable();

    if (!result) {
      throw ERRORS.USER_REJECTED;
    }

    return data.accounts;
  }

  const response = await provider.getMethod(method)(...request.params);

  if (response.result === false) throw ERRORS.USER_REJECTED;
  else return response;
};

const provider = (chain) => {
  chain = chain.toLowerCase();

  if (!Object.keys(SUPPORTED_CHAINS).includes(chain)) {
    console.error('Unsupported chain:', chain);
  }

  return {
    request: async (req) => {
      const params = req.params || [];

      return handleRequest(chain, {
        method: req.method,
        params,
      });
    },
    on: (method, callback) => {
      let origin = window.location.hostname;
      if (window.location.port) {
        origin += `:${window.location.port}`;
      }

      const id = `${chain}.${origin}.${method}`;

      window.pali._listeners[id] = ({ detail }) => {
        if (detail) {
          callback(JSON.parse(detail));
        }
      };

      window.addEventListener(id, window.pali._listeners[id], {
        passive: true,
      });

      // Register the origin of the listening site.
      window.postMessage(
        {
          id,
          type: 'PALI_EVENT_REG',
          data: {
            method,
            origin,
            chain,
          },
        },
        '*'
      );
    },
    removeListener: (method) => {
      let origin = window.location.hostname;
      if (window.location.port) {
        origin += `:${window.location.port}`;
      }

      const id = `${chain}.${origin}.${method}`;

      if (window.pali._listeners[id]) {
        window.removeEventListener(id, window.pali._listeners[id]);

        delete window.pali._listeners[id];
      }

      window.postMessage(
        {
          id,
          type: 'PALI_EVENT_DEREG',
          data: {
            method,
            origin,
            chain,
          },
        },
        '*'
      );
    },
  };
};

const ethProvider = provider('ethereum');
const sysProvider = provider('syscoin');

window.pali = {
  version: 2,
  getProvider: (chain) => provider(chain),
  isConnected: async () => {
    const pali = window.providerManager.getProviderFor('SYS');

    return pali.getMethod('isConnected')();
  },
  enable: async () => {
    const response = await window.providerManager.enable();

    if (!response) throw ERRORS.USER_REJECTED;

    return response;
  },
  disable: async () => window.providerManager.disable(),
  request: async (req) => sysProvider.request(req),
  on: (method, callback) => sysProvider.on(method, callback),
  removeListener: (method) => sysProvider.removeListener(method),
  _listeners: {},
};
