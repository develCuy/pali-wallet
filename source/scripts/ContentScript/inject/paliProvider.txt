const SUPPORTED_CHAINS = ['syscoin', 'ethereum'];

const { SUPPORTED_WALLET_METHODS } = window;

const REQUEST_MAP = {
  ETH: {
    chainId: SUPPORTED_WALLET_METHODS.getChainId,
    setAccount: SUPPORTED_WALLET_METHODS.setAccount,
    accounts: SUPPORTED_WALLET_METHODS.getAccounts,
    blockNumber: SUPPORTED_WALLET_METHODS.getBlockNumber,
    estimateGas: SUPPORTED_WALLET_METHODS.estimateGas,
    sendTransaction: SUPPORTED_WALLET_METHODS.sendTransaction,
    signMessage: SUPPORTED_WALLET_METHODS.signMessage,
    getBalance: SUPPORTED_WALLET_METHODS.getBalance,
  },
  SYS: {
    setAccount: SUPPORTED_WALLET_METHODS.setAccount,
    chainId: SUPPORTED_WALLET_METHODS.getChainId,
    accounts: SUPPORTED_WALLET_METHODS.getAccounts,
    sendTransaction: SUPPORTED_WALLET_METHODS.sendTransaction,
    getPublicKey: SUPPORTED_WALLET_METHODS.getPublicKey,
    signMessage: SUPPORTED_WALLET_METHODS.signMessage,
    getBalance: SUPPORTED_WALLET_METHODS.getBalance,
  },
  isConnected: SUPPORTED_WALLET_METHODS.isConnected,
  getNetwork: SUPPORTED_WALLET_METHODS.getNetwork,
  getAddress: SUPPORTED_WALLET_METHODS.getAddress,
};

const ERRORS = {
  USER_REJECTED: new Error('User rejected the request'),
  INVALID_METHOD: new Error('Invalid method'),
};

const request = async (req) => {
  const { method, args, chain } = req;
  const prefix = chain?.substring(0, 3).toUpperCase();

  console.log('handling request', req);

  //* Prefix / Method validation
  if (!method) throw ERRORS.INVALID_METHOD;

  if (chain && !SUPPORTED_CHAINS.includes(chain)) {
    throw ERRORS.INVALID_METHOD;
  }

  let method_ = prefix ? REQUEST_MAP[prefix][method] : REQUEST_MAP[method];
  if (!method_) throw ERRORS.INVALID_METHOD;

  //* Call the method
  const response = await window.providerManager.proxy('CAL_REQUEST', {
    chain,
    method,
    args,
  });

  if (response.result === false) throw ERRORS.USER_REJECTED;
  else return response;
};

const on = (method, callback) => {
  let origin = window.location.hostname;
  if (window.location.port) {
    origin += `:${window.location.port}`;
  }

  const id = `${origin}.${method}`;

  window.pali._listeners[id] = ({ detail }) => {
    if (detail) {
      callback(JSON.parse(detail));
    }
  };

  window.addEventListener(id, window.pali._listeners[id], {
    passive: true,
  });

  // Register the origin of the listening site.
  window.postMessage(
    {
      id,
      type: 'PALI_EVENT_REG',
      data: {
        method,
        origin,
      },
    },
    '*'
  );
};

const removeListener = (method) => {
  let origin = window.location.hostname;
  if (window.location.port) {
    origin += `:${window.location.port}`;
  }

  const id = `${origin}.${method}`;

  if (window.pali._listeners[id]) {
    window.removeEventListener(id, window.pali._listeners[id]);

    delete window.pali._listeners[id];
  }

  window.postMessage(
    {
      id,
      type: 'PALI_EVENT_DEREG',
      data: {
        method,
        origin,
      },
    },
    '*'
  );
};

window.pali = Object.freeze({
  version: 2,
  request,
  on,
  removeListener,
  isConnected: () => request({ method: 'isConnected' }),
  enable: async () => {
    const response = await window.providerManager.enable();

    if (!response) throw ERRORS.USER_REJECTED;

    return response;
  },
  disable: async () => window.providerManager.disable(),
  _listeners: {},
});
